자료 구조 == 데이터 구조 == data structure

대표적인 자료 구조
    배열, 스택, 큐, 링크드 리스트, 해쉬 테이블, 힙 등

알고리즘 / algorithm
    어떤 문제를 풀기 위한 절차/방법
    어떤 문제에 대해, 특정한 ‘입력’을 넣으면, 원하는 ‘출력’을 얻을 수 있도록 만드는 프로그래밍
    
    알고리즘 성능의 주 요소 - 시간, 메모리


배열 / Array    
    데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조 (ex 파이썬 - list)

    배열 장점
        빠른 접근 가능
    배열 단점
        추가 삭제가 쉽지 않음


큐 / Queue
    가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 구조
    First in First out (FIFO)
    Last in Last out (LILO)

    Enqueue 큐에서 데이터 넣는 것
    Dequeue 큐에서 데이터 꺼내는 것

    Last in First out (LIFO) Queue

    PriorityQueue 우선순위 큐 (중요)
        큐를 넣을 때 우선순위를 같이 넣음 (튜플 형태)

    큐의 사용
        멀티 테스킹을 위한 프로세스 스케쥴링 방식을 구현하기 위해 사용 (운영체제)


스택 / Stack
    데이터를 제한적으로 접근할 수 있는 구조
        (한쪽 끝에서마 자료를 넣거나 뺄 수 있는 구조)
    가장 나중에 쌓은 데이터를 가장 먼저 꺼낼 수 있는 구조
        큐 : FIFO 정책
        스택 : LIFO 정책

    스택 구조 (큐와 반대 정책)
        LIFO - FILO
    사용 
        컴퓨터 내부의 프로세스 구조의 함수 동작 방식
    스택의 장단점
        장점	구조가 단순해서 구현이 쉽다
            데이터 저장/읽기 속도가 빠르다
        단점 데이터의 최대 갯수를 지정해 두어야한다.
            재귀함수를 1000번까지 지정 -> 1000번할 메모리 확보해두어야함


링크드 리스트 / Linked List
    연결 리스트
    노드(Node) - 데이터 저장 단위(데이터값, 포인터)로 구성
    포인터(Pointer) - 각 노드 안에서, 다음이나 이전의 노드와의 연결 정보를 가지고 있는 공간

    장단점
        장점	미리 데이터 공간을 미리 할당하지 않아도 됨
        단점	연결을 위한 별도 데이터 공간(포인터)가 필요하므로, 저장공간의 효율이 높지 않음
            연결 정보를 찾는 시간이 필요하므로 접근 속도가 느림
		중간 데이터 추가 및 삭제 시, 앞뒤 데이터의 연결을 재구성해야 하는 부가적인 작업 필요


알고리즘 복잡도 표현 방법 
	시간 복잡도	: 알고리즘 실행 속도 (중요)
	공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈
	=> 이전은 메모리가 중요하여 공간복잡도가 중요했지만, 
		요즘은 하드웨어가 발전하여 시간 복잡도가 더 중요해졌다
시간 복잡도
	핵심 요소 -> 반복문 
	Big O 표기법 : O(N)
		알고리즘 최악의 실행 시간을 표기
		가장 많이/일반적으로 사용함
		아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미이기 때문
		입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
		O(1) < O(log n) < O(n) < O(nlog n) < O(n^2) < O(n!)
		(log n 의 베이스는 2 - log2 n)
	입력 n에 따라, 몇번 실행이 되는지를 계산하면 됨
		표현식에 가장 큰 영향을 미치는 n의 단위로 표기합니다.
		n이 1이든 100이든, 1000이든, 10000이든 실행을
			무조건 2회(상수회) 실행한다 : O(1)
			n에 따라 n번, n+10번, 또는 3n + 10번 등 실행한다 : O(n)
			n에 따라, n^2번, n^2 +1000 번, 또는 100n^2 - 100 번 등 실행한다 : O(n^2)

	sum의 예시  => 1부터 n까지의 합
	1. O(n)
		for(int i = 0; i < n ; ++i)
			sum += i;
	2. O(1)
		sum = n * (n + 1) / 2;


해쉬 테이블 / Hash Table
	Hash Table => Key에 Value를 저장하는 데이터 구조 (ex 파이썬 -> Dic)
	보통 배열로 미리 Hash Table 사이즈 만큼 생성 후에 사용 (공간과 탐색 시간을 맞바꾸는 기법)
    
    알아둘 용어
        해쉬(Hash) : 임의 값을 고정 길이로 변환하는 것
        해쉬 테이블(Hash Table) : 키 값의 연산에 의해 직접 접근이 가능한 데이터 구조
        해싱 함수(Hashing Function) : Key에 대해 산술 연산을 이용해 데이터 위치를 찾을 수 있는 함수)
        해쉬 값(Hash Value) 또는 해쉬 주소(Hash address) : Key를 해싱 함수로 연산해서, 해쉬 값을 알아내고, 이	를 기반으로 해쉬 테이블에서 해당 Key에 대한 데이터 위치를 일관성 있게 찾을 수 있음
        슬롯(Slot) : 한 개의 데이터를 저장할 수 있는 공간
            참고 : 저장할 데이터에 대해 Key를 추출할 수 있는 별도 함수도 존재할 수 있음
    장단점
        장점
            데이터 저장/읽기 속도가 빠르다. (검색 속도가 빠르다.)
            해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉬움
        단점
            일반적으로 저장공간이 많이 필요함
            여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요함
    주요 용도
        검색이 많이 필요한 경우
        저장, 삭제, 읽기가 빈번한 경우
        캐쉬 구현 시 (중복 확인이 쉽기 때문)
    해쉬 충돌 (Hash Collision)
        해쉬 테이블의 다른 데이터가 같은 키값을 가지는 경우
        Chaining 기법
            Open Hashing 기법 (개방 해슁) => 해쉬 테이블 저장공간 외의 공간을 활용하는 기법
            충돌이 일어나면, 링크드 리스트라는 자료 구조를 사용해서, 
                링크드 리스트로 데이터를 추가로 뒤에 연결시켜서 저장하는 기법
        Linear Probing 기법 (많이 쓰임)
            Close Hashing 기법(폐쇄 해슁) => 해쉬 테이블 저장공간 안에 충돌 문제를 해결하는 기법
            충돌이 일어나면, 해당 hash address부터 맨 처음 나오는 빈공간에 저장하는 기법
                => 저장공간 활용도를 높이기 위한 기법
        빈번한 충돌을 개선하는 기법
            해쉬함수를 재정의 및 해쉬 테이블 저장공간을 확대
    시간 복잡도
        일반적인 경우 (Collision이 없는 경우)는 O(1)
        최악의 경우(Collision이 모두 발생하는 경우)는 O(n)
            해쉬 테이블의 경우, 일반적인 경우를 기대하고 만들기 때문에, 시간 복잡도는 O(1) 이라고 말할 	수 있음
    검색에서 해쉬 테이블의 사용 예
        16개의 배열 내 데이터를 저장하고, 검색할 때 O(n)
        16개의 데이터 저장공간을 가진 위의 해쉬 테이블에 데이터를 저장하고, 검색할 때 O(1)


트리 구조 Tree Structure
	트리 : Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조
	실제로는 이진 트리 (Binary Tree)형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용됨

    알아둘 용어
        Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)
        Root Node : 트리 맨 위에 있는 노드
        Level : 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄
        Parent Node : 어떤 노드의 다음 레벨에 연결된 노드
        Child Node : 어떤 노드의 상위 레벨에 연결된 노드
        Leaf Node (Terminal Node) : Child Node가 하나도 없는 노드
        Sibling (Brother Node) : 동일한 Parent Node를 가진 노드
        Depth : 트리에서 Node가 가질 수 있는 최대 Level
    이진 트리와 이진 탐색 트리 (Binary Search Tree)
        이진 트리 : 노드의 최대 Branch가 2인 트리
        이진 탐색 트리 (Binary Search Tree, BST) : 이진 트리에 다음과 같은 추가적인 조건이 있는 트리
            왼쪽 노드는 해당 노드보다 작은 값, 오른쪽 노드는 해당 노드보다 큰 값을 가지고 있음
    Node 삭제
        Child Node가 하나인 Node 삭제
            삭제할 Node의 Parent Node가 삭제할 Node의 Child Node를 가리키도록 한다.
        Child Node가 두개인 Node 삭제
            삭제할 Node의 오른쪽 자식 중, 가장 작은 값을 삭제할 Node의 Parent Node가 가리키도록 한다.
            삭제할 Node의 왼쪽 자식 중, 가장 큰 값을 삭제할 Node의 Parent Node가 가리키도록 한다.

    이진 탐색 트리의 시간 복잡도와 단점
        시간복잡도 (탐색 시)
            depth (트리의 높이) 를 h라고 표기한다면, O(h)
            n개의 노드를 가진다면, h = log2 n 에 가까우므로, 시간 복잡도는 O(logn)
                한번 실행 시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미
                ,즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미함
        이진 탐색 트리의 단점
            균형이 무너지면 O(n)의 시간 복잡도를 가지게 됨 (링크드 리스트와 동일)


힙 / Heap
	힙 : 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리(Complete Binary Tree)
		완전 이진 트리 : 노드를 삽입할 때, 최하단 왼쪽 노드부터 차례대로 삽입하는 트리
	힙을 사용하는 이유
		배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 O(n)이 걸림
		이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면, O(logn)이 걸림
		우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됨

    힙의 구조
        힙은 최대값을 구하기 위한 구조 (최대 힙, Max Heap)와, 최소값을 구하기 위한 구조 (최소 힙, Min Heap)로 분류할 수 있음
        힙은 다음과 같이 두가지 조건을 가지고 있는 자료구조임
        1. 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같다. (최대 힙의 경우)
            최소 힙의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 작음
        2. 완전 이진 트리 형태를 가짐
    힙과 이진 탐색 트리의 공통점과 차이점
        공통점 : 힙과 이진 탐색 트리는 모두 이진 트리임
        차이점 : 
            힙은 각 노드의 값이 자식 노드보다 크거나 작고, 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼
            이진 탐색 트리는 왼쪽 자식 노드의 값이 가장 작고, 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼
            힙은 이진 탐색 트리의 조건인 자식 노드에서 작은 값은 왼쪽, 큰 값은 오른쪽이라는 조건은 없음
                힙의 왼쪽 및 오른쪽 자식 노드의 값은 오른쪽이 클 수도 있고, 왼쪽이 클 수도 있음
            이진 탐색 트리는 탐색을 위한 구조, 힙은 최대/최소값 검색을 위한 구조 중 하나로 이해하면 됨
    힙 데이터 삽입 - 기본동작
        힙은 완전 이진 트리이므로, 삽입할 노드는 기본적으로 왼쪽 최하단부 노드부터 채워지는 형태로 삽입
    힙 데이터 삽입 - 삽입할 데이터가 힙의 데이터보다 클 경우 (Max Heap의 예)
        먼저 삽입된 데이터는 완전 이진 트리 구조에 맞추어, 최하단 왼쪽 노드부터 채워짐
        채워진 노드 위치에서, 부모 노드보다 값이 클 경우, 부모 노드와 위치를 바꿔주는 작업을 반복함 (swap)
    힙 데이터 삭제 (Max Heap의 예 -> 보통 Max만 삭제한다)
        보통 삭제는 최상단 root Node를 삭제하는 것이 일반적임
            힙의 용도는 최대값 또는 최소값을 root노드에 놓아서, 최대값과 최소값을 바로 꺼내 쓸 수 있도록 하는것임
        상단의 데이터 삭제시, 가장 최하단부 왼쪽에 위치한 노드(일반적으로 가장 마지막에 추가한 노드)를 Root 노드로 이동
        root노드의 값이 Child Node보다 작을 경우, root노드의 Child Node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복함 (swap)
            자식 노드 중 더 큰 값을 올림
    힙과 배열
        일반적으로 힙 구현 시 배열 자료구조를 활용함
        배열은 인덱스가 0번부터 시작하지만, 힙 구현의 편의를 위해, root 노드 인덱스 번호를 1로 지정하면, 구현이 좀 더 수월함
            부모 노드 인덱스 번호 (Parent Node’s index) = 자식 노드 인덱스 번호 (Child Node’s index)/2 (int형이니 몫)
            왼쪽 자식 노드 인덱스 번호 (Left Child Node’s index) = 부모 노드 인덱스 번호 (Parent Node’s index) * 2
            오른쪽 자식 노드 인덱스 번호 (Right Child Node’s index) = 부모 노드 인덱스 번호 (Parent Node’s index) *2 + 1
    힙(Heap) 시간 복잡도
        depth (트리의 높이)를 h라고 표기한다면
        n개의 노드를 가지는 heap에 데이터 삽입 또는 삭제 시, 최악의 경우 root노드에서 leaf노드까지 비교해야 하므로 h = log2 n 에 가깝고, 시간 복잡도는 O(logn)
            참고 : 한번 실행 시마다 50%의 실행할 수도 있는 명령을 제거한다는 의미, 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미함  